package com.noovoweb.validator.ksp

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy

/**
 * Generates complete validator classes for @Validated data classes.
 *
 * Generates a class that implements GeneratedValidator<T> with:
 * - validate() method (exception-based API)
 * - validateResult() method (result-based API)
 * - validateParallel() helper (validates fields in parallel)
 * - validateSequential() helper (validates fields sequentially)
 * - validateFieldX() methods for each property
 */
internal class ValidatorClassGenerator(
    private val fieldValidatorCodeGenerator: FieldValidatorCodeGenerator,
) {
    /**
     * Generate a complete validator class for the given validated class.
     *
     * @param classInfo Information about the @Validated class
     * @return FileSpec containing the generated validator class
     */
    internal fun generate(classInfo: ValidatedClassInfo): FileSpec {
        val validatorClassName = ClassName(classInfo.packageName, classInfo.validatorClassName)
        val dataClassName = ClassName(classInfo.packageName, classInfo.className)

        val validatorClass =
            TypeSpec.classBuilder(validatorClassName)
                .addAnnotation(
                    AnnotationSpec.builder(Suppress::class)
                        .addMember("%S, %S", "USELESS_IS_CHECK", "REDUNDANT_ELSE_IN_WHEN")
                        .build(),
                )
                .addSuperinterface(
                    ClassName("com.noovoweb.validator", "GeneratedValidator")
                        .parameterizedBy(dataClassName),
                )
                .addKdoc(
                    """
                    Generated validator for ${classInfo.className}.

                    This validator is automatically generated by KSP at compile-time.
                    It implements all validators defined via annotations.

                    **100%% Non-Blocking**: All validation is performed using suspend functions
                    with proper dispatcher usage for I/O operations.
                    """.trimIndent(),
                )
                .apply {
                    // Add companion object with cached regex patterns for @Pattern validators
                    val companionObject = generateCompanionObject(classInfo)
                    if (companionObject != null) {
                        addType(companionObject)
                    }
                }
                .addFunction(generateValidateMethod(classInfo, dataClassName))
                .addFunction(generateValidateResultMethod(classInfo, dataClassName))
                .addFunction(generateValidateParallelMethod(classInfo, dataClassName))
                .addFunction(generateValidateSequentialMethod(classInfo, dataClassName))
                .apply {
                    // Generate individual field validation methods
                    classInfo.properties.forEach { property ->
                        if (property.hasValidators() || property.hasNestedValidation()) {
                            addFunction(generateFieldValidationMethod(property, classInfo, dataClassName))
                        }
                    }
                }
                .build()

        return FileSpec.builder(classInfo.packageName, classInfo.validatorClassName)
            .addType(validatorClass)
            .addImport("kotlinx.coroutines", "coroutineScope", "async", "awaitAll", "withContext")
            .addImport("kotlinx.coroutines", "Dispatchers")
            .build()
    }

    /**
     * Generate the validate() method (exception-based API).
     */
    private fun generateValidateMethod(
        classInfo: ValidatedClassInfo,
        dataClassName: ClassName,
    ): FunSpec {
        return FunSpec.builder("validate")
            .addModifiers(KModifier.OVERRIDE, KModifier.SUSPEND)
            .addParameter("payload", dataClassName)
            .addParameter("context", ClassName("com.noovoweb.validator", "ValidationContext"))
            .addCode(
                CodeBlock.builder()
                    .addStatement("// Validate all fields in parallel")
                    .addStatement("val errors = validateParallel(payload, context)")
                    .addStatement("")
                    .addStatement("// Throw exception if validation failed")
                    .beginControlFlow("if (errors.isNotEmpty())")
                    .addStatement(
                        "throw %T(errors)",
                        ClassName("com.noovoweb.validator", "ValidationException"),
                    )
                    .endControlFlow()
                    .build(),
            )
            .build()
    }

    /**
     * Generate the validateResult() method (result-based API).
     */
    private fun generateValidateResultMethod(
        classInfo: ValidatedClassInfo,
        dataClassName: ClassName,
    ): FunSpec {
        return FunSpec.builder("validateResult")
            .addModifiers(KModifier.OVERRIDE, KModifier.SUSPEND)
            .addParameter("payload", dataClassName)
            .addParameter("context", ClassName("com.noovoweb.validator", "ValidationContext"))
            .returns(
                ClassName("com.noovoweb.validator", "ValidationResult")
                    .parameterizedBy(dataClassName),
            )
            .addCode(
                CodeBlock.builder()
                    .addStatement("// Validate all fields in parallel")
                    .addStatement("val errors = validateParallel(payload, context)")
                    .addStatement("")
                    .addStatement("// Return Result based on validation outcome")
                    .beginControlFlow("return if (errors.isEmpty())")
                    .addStatement(
                        "%T.Success(payload)",
                        ClassName("com.noovoweb.validator", "ValidationResult"),
                    )
                    .nextControlFlow("else")
                    .addStatement("// Convert string errors to ValidationError objects")
                    .addStatement("val errorObjects = errors.mapValues { (_, messages) ->")
                    .indent()
                    .addStatement(
                        "messages.map { %T(it) }",
                        ClassName("com.noovoweb.validator", "ValidationError"),
                    )
                    .unindent()
                    .addStatement("}")
                    .addStatement(
                        "%T.Failure(errorObjects)",
                        ClassName("com.noovoweb.validator", "ValidationResult"),
                    )
                    .endControlFlow()
                    .build(),
            )
            .build()
    }

    /**
     * Generate the validateParallel() helper method.
     */
    private fun generateValidateParallelMethod(
        classInfo: ValidatedClassInfo,
        dataClassName: ClassName,
    ): FunSpec {
        return FunSpec.builder("validateParallel")
            .addModifiers(KModifier.PRIVATE, KModifier.SUSPEND)
            .addParameter("payload", dataClassName)
            .addParameter("context", ClassName("com.noovoweb.validator", "ValidationContext"))
            .returns(MAP.parameterizedBy(STRING, LIST.parameterizedBy(STRING)))
            .addCode(
                CodeBlock.builder()
                    .addStatement("// Validate all fields in parallel using async")
                    .addStatement("return coroutineScope {")
                    .indent()
                    .addStatement("val validations = listOf(")
                    .indent()
                    .apply {
                        classInfo.properties.forEach { property ->
                            if (property.hasValidators() || property.hasNestedValidation()) {
                                addStatement(
                                    "async(context.dispatcher) { validate%L(payload, context) },",
                                    property.name.capitalize(),
                                )
                            }
                        }
                    }
                    .unindent()
                    .addStatement(")")
                    .addStatement("")
                    .addStatement("// Wait for all validations to complete")
                    .addStatement("val allErrors = validations.awaitAll()")
                    .addStatement("")
                    .addStatement("// Merge all error maps")
                    .addStatement("allErrors.fold(mutableMapOf<String, List<String>>()) { acc, errors ->")
                    .indent()
                    .addStatement("acc.putAll(errors)")
                    .addStatement("acc")
                    .unindent()
                    .addStatement("}")
                    .unindent()
                    .addStatement("}")
                    .build(),
            )
            .build()
    }

    /**
     * Generate the validateSequential() helper method.
     */
    private fun generateValidateSequentialMethod(
        classInfo: ValidatedClassInfo,
        dataClassName: ClassName,
    ): FunSpec {
        return FunSpec.builder("validateSequential")
            .addModifiers(KModifier.PRIVATE, KModifier.SUSPEND)
            .addParameter("payload", dataClassName)
            .addParameter("context", ClassName("com.noovoweb.validator", "ValidationContext"))
            .returns(MAP.parameterizedBy(STRING, LIST.parameterizedBy(STRING)))
            .addCode(
                CodeBlock.builder()
                    .addStatement("// Validate all fields sequentially")
                    .addStatement("val allErrors = mutableMapOf<String, List<String>>()")
                    .addStatement("")
                    .apply {
                        classInfo.properties.forEach { property ->
                            if (property.hasValidators() || property.hasNestedValidation()) {
                                addStatement(
                                    "allErrors.putAll(validate%L(payload, context))",
                                    property.name.capitalize(),
                                )
                            }
                        }
                    }
                    .addStatement("")
                    .addStatement("return allErrors")
                    .build(),
            )
            .build()
    }

    /**
     * Generate a field validation method for a single property.
     */
    private fun generateFieldValidationMethod(
        property: PropertyInfo,
        classInfo: ValidatedClassInfo,
        dataClassName: ClassName,
    ): FunSpec {
        return FunSpec.builder("validate${property.name.capitalize()}")
            .addModifiers(KModifier.PRIVATE, KModifier.SUSPEND)
            .addParameter("payload", dataClassName)
            .addParameter("context", ClassName("com.noovoweb.validator", "ValidationContext"))
            .returns(MAP.parameterizedBy(STRING, LIST.parameterizedBy(STRING)))
            .addCode(generateFieldValidationCode(property, classInfo))
            .build()
    }

    /**
     * Generate the validation code for a single field.
     */
    private fun generateFieldValidationCode(
        property: PropertyInfo,
        classInfo: ValidatedClassInfo,
    ): CodeBlock {
        return CodeBlock.builder().apply {
            addStatement("val errors = mutableListOf<String>()")
            addStatement("val value = payload.%L", property.name)
            addStatement("")

            // Generate validators with fail-fast checkpoints
            property.validators.forEachIndexed { index, validator ->
                add(fieldValidatorCodeGenerator.generateValidatorCode(validator, property, property.name))
                addStatement("")

                // Check if there's a @FailFast checkpoint after this validator
                if (property.shouldFailFastAfter(index)) {
                    addStatement("// ðŸ›‘ CHECKPOINT: @FailFast detected at this position")
                    addStatement("if (errors.isNotEmpty()) return mapOf(%S to errors)", property.name)
                    addStatement("")
                }
            }

            // Generate nested validation if present
            if (property.hasNestedValidation()) {
                addStatement("val nestedErrors = mutableMapOf<String, List<String>>()")
                add(generateNestedValidation(property))
                addStatement("")
                addStatement("// Merge field-level and nested errors")
                addStatement("val allErrors = mutableMapOf<String, List<String>>()")
                addStatement("if (errors.isNotEmpty()) {")
                indent()
                addStatement("allErrors[%S] = errors", property.name)
                unindent()
                addStatement("}")
                addStatement("allErrors.putAll(nestedErrors)")
                addStatement("return allErrors")
            } else {
                addStatement("return if (errors.isEmpty()) emptyMap() else mapOf(%S to errors)", property.name)
            }
        }.build()
    }

    /**
     * Generate nested validation code for @Valid annotation.
     */
    private fun generateNestedValidation(property: PropertyInfo): CodeBlock {
        val nestedInfo = property.nestedValidation!!

        return if (nestedInfo.validateEachElement) {
            // @Valid(each = true) - validate collection elements in parallel
            CodeBlock.builder()
                .addStatement("// @Valid(each = true) - Validate collection elements in parallel")
                .beginControlFlow("value?.let { collection ->")
                .addStatement("coroutineScope {")
                .indent()
                .addStatement("@Suppress(%S, %S)", "USELESS_IS_CHECK", "USELESS_CAST")
                .addStatement("val nestedValidations = when (collection) {")
                .indent()
                .addStatement("is Collection<*> -> collection.mapIndexed { index, item ->")
                .indent()
                .addStatement("async(context.dispatcher) {")
                .indent()
                .beginControlFlow("try")
                .addStatement("// Get validator for nested type")
                .addStatement("val validator = %LValidator()", property.type.typeArguments.firstOrNull()?.simpleName ?: "Unknown")
                .addStatement("validator.validate(item as %L, context)", property.type.typeArguments.firstOrNull()?.simpleName ?: "Any")
                .addStatement("emptyMap<String, List<String>>()")
                .nextControlFlow("catch (e: %T)", ClassName("com.noovoweb.validator", "ValidationException"))
                .addStatement("e.errors.mapKeys { (field, _) -> \"%L[\$index].\$field\" }", property.name)
                .endControlFlow()
                .unindent()
                .addStatement("}")
                .unindent()
                .addStatement("}")
                .addStatement("is Array<*> -> (collection as Array<*>).mapIndexed { index, item ->")
                .indent()
                .addStatement("async(context.dispatcher) {")
                .indent()
                .beginControlFlow("try")
                .addStatement("val validator = %LValidator()", property.type.typeArguments.firstOrNull()?.simpleName ?: "Unknown")
                .addStatement("validator.validate(item as %L, context)", property.type.typeArguments.firstOrNull()?.simpleName ?: "Any")
                .addStatement("emptyMap<String, List<String>>()")
                .nextControlFlow("catch (e: %T)", ClassName("com.noovoweb.validator", "ValidationException"))
                .addStatement("e.errors.mapKeys { (field, _) -> \"%L[\$index].\$field\" }", property.name)
                .endControlFlow()
                .unindent()
                .addStatement("}")
                .unindent()
                .addStatement("}")
                .addStatement("else -> emptyList()")
                .unindent()
                .addStatement("}")
                .addStatement("")
                .addStatement("// Wait for all nested validations and collect errors")
                .addStatement("val allNestedErrors = nestedValidations.awaitAll()")
                .addStatement("allNestedErrors.forEach { errorMap ->")
                .indent()
                .addStatement("nestedErrors.putAll(errorMap)")
                .unindent()
                .addStatement("}")
                .unindent()
                .addStatement("}")
                .endControlFlow()
                .build()
        } else {
            // @Valid - validate single nested object
            CodeBlock.builder()
                .addStatement("// @Valid - Validate nested object")
                .beginControlFlow("value?.let { nestedObject ->")
                .beginControlFlow("try")
                .addStatement("val validator = %LValidator()", property.type.simpleName)
                .addStatement("validator.validate(nestedObject, context)")
                .nextControlFlow("catch (e: %T)", ClassName("com.noovoweb.validator", "ValidationException"))
                .addStatement("e.errors.forEach { (field, messages) ->")
                .indent()
                .addStatement("val path = \"%L.\$field\"", property.name)
                .addStatement("errors.addAll(messages)")
                .unindent()
                .addStatement("}")
                .endControlFlow()
                .endControlFlow()
                .build()
        }
    }

    /**
     * Extension function to capitalize first letter.
     */
    private fun String.capitalize(): String {
        return this.replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }
    }

    /**
     * Generate companion object with cached regex patterns.
     *
     * This improves performance by compiling regex patterns once at class initialization
     * instead of on every validation, and provides ReDoS protection.
     */
    private fun generateCompanionObject(classInfo: ValidatedClassInfo): TypeSpec? {
        // Collect all @Pattern validators
        val patternValidators = mutableListOf<Pair<String, String>>() // property name to pattern

        // Collect built-in regex validators (for caching performance)
        val builtInRegexes = mutableMapOf<String, String>()

        classInfo.properties.forEach { property ->
            property.validators.forEach { validator ->
                if (validator is ValidationValidatorInfo.PatternValidator) {
                    patternValidators.add(property.name to validator.pattern)
                }

                // OPTIMIZATION: Cache built-in regex patterns for performance
                when (validator) {
                    is ValidationValidatorInfo.EmailValidator -> {
                        builtInRegexes["emailRegex"] = ValidationPatterns.EMAIL
                    }
                    is ValidationValidatorInfo.UuidValidator -> {
                        builtInRegexes["uuidRegex"] = ValidationPatterns.UUID
                    }
                    is ValidationValidatorInfo.AlphaValidator -> {
                        builtInRegexes["alphaRegex"] = ValidationPatterns.ALPHA
                    }
                    is ValidationValidatorInfo.AlphanumericValidator -> {
                        builtInRegexes["alphanumericRegex"] = ValidationPatterns.ALPHANUMERIC
                    }
                    is ValidationValidatorInfo.AsciiValidator -> {
                        builtInRegexes["asciiRegex"] = ValidationPatterns.ASCII
                    }
                    is ValidationValidatorInfo.MacAddressValidator -> {
                        builtInRegexes["macRegex"] = ValidationPatterns.MAC_ADDRESS
                    }
                    is ValidationValidatorInfo.IsoDateValidator -> {
                        builtInRegexes["isoDateRegex"] = ValidationPatterns.ISO_DATE
                    }
                    is ValidationValidatorInfo.IsoDateTimeValidator -> {
                        builtInRegexes["isoDateTimeRegex"] = ValidationPatterns.ISO_DATETIME
                    }
                    else -> {
                        // Other validators don't need regex caching
                    }
                }
            }
        }

        // Only generate companion if there are any regex patterns
        if (patternValidators.isEmpty() && builtInRegexes.isEmpty()) {
            return null
        }

        return TypeSpec.companionObjectBuilder()
            .addKdoc(
                """
                Cached regex patterns for performance and ReDoS protection.

                Patterns are compiled once at class initialization instead of on every validation.
                All patterns are validated at compile-time for safety.

                PERFORMANCE: Built-in patterns (Email, UUID, etc.) are cached here for 10-100x speedup.
                """.trimIndent(),
            )
            .apply {
                // Add user-defined @Pattern validators
                patternValidators.forEach { (propertyName, pattern) ->
                    addProperty(
                        PropertySpec.builder("${propertyName}Regex", ClassName("kotlin.text", "Regex"))
                            .addModifiers(KModifier.PRIVATE)
                            .initializer("Regex(%S)", pattern)
                            .build(),
                    )
                }

                // Add built-in regex validators (Email, UUID, etc.)
                builtInRegexes.forEach { (regexName, pattern) ->
                    addProperty(
                        PropertySpec.builder(regexName, ClassName("kotlin.text", "Regex"))
                            .addModifiers(KModifier.PRIVATE)
                            .initializer("Regex(%S)", pattern)
                            .build(),
                    )
                }
            }
            .build()
    }
}
